
@inproceedings{tripon_angular_2021,
	title = {Angular and {Svelte} {Frameworks}: a {Comparative} {Analysis}},
	shorttitle = {Angular and {Svelte} {Frameworks}},
	doi = {10.1109/EMES52337.2021.9484119},
	abstract = {Web-based and mobile applications are increasingly used today in all areas of our life. In order to deliver software products as fast, as simple and economically possible, several cross-platform frameworks were created. The challenge is to choose the best framework that produces the desired solution and that integrates best with the existing systems and with higher user experience results. This paper describes and analyses the performance of two frameworks, Angular and Svelte, used for application development based on the implementation of a small applications. Results reveal that an important factor considered to choose the framework is the target device on which the application runs and also the complexity of the application.},
	booktitle = {2021 16th {International} {Conference} on {Engineering} of {Modern} {Electric} {Systems} ({EMES})},
	author = {Tripon, Teodor-Dorin and Adela Gabor, Gianina and Valentina Moisi, Elisa},
	month = jun,
	year = {2021},
	keywords = {Angular, Complexity theory, framework, mobile application, Mobile applications, Performance evaluation, Software, Svelte, Testing, Tools, User experience, web-based application},
	pages = {1--4},
	file = {IEEE Xplore Full Text PDF:/home/hannah/Zotero/storage/6J2Q8WNH/Tripon et al. - 2021 - Angular and Svelte Frameworks a Comparative Analy.pdf:application/pdf},
}

@inproceedings{feigenspan_measuring_2012,
	title = {Measuring programming experience},
	doi = {10.1109/ICPC.2012.6240511},
	abstract = {Programming experience is an important confounding parameter in controlled experiments regarding program comprehension. In literature, ways to measure or control programming experience vary. Often, researchers neglect it or do not specify how they controlled it. We set out to find a well-defined understanding of programming experience and a way to measure it. From published comprehension experiments, we extracted questions that assess programming experience. In a controlled experiment, we compare the answers of 128 students to these questions with their performance in solving program-comprehension tasks. We found that self estimation seems to be a reliable way to measure programming experience. Furthermore, we applied exploratory factor analysis to extract a model of programming experience. With our analysis, we initiate a path toward measuring programming experience with a valid and reliable tool, so that we can control its influence on program comprehension.},
	booktitle = {2012 20th {IEEE} {International} {Conference} on {Program} {Comprehension} ({ICPC})},
	author = {Feigenspan, Janet and Kästner, Christian and Liebig, Jörg and Apel, Sven and Hanenberg, Stefan},
	month = jun,
	year = {2012},
	note = {ISSN: 1092-8138},
	keywords = {Educational institutions, Estimation, Programming profession, Software engineering, Time factors},
	pages = {73--82},
	file = {IEEE Xplore Full Text PDF:/home/hannah/Zotero/storage/4QHZNE7N/Feigenspan et al. - 2012 - Measuring programming experience.pdf:application/pdf},
}

@article{morales_programmer_2019,
	title = {Programmer {eXperience}: {A} {Systematic} {Literature} {Review}},
	volume = {7},
	issn = {2169-3536},
	shorttitle = {Programmer {eXperience}},
	doi = {10.1109/ACCESS.2019.2920124},
	abstract = {Programmers use various software development artifacts in their work, such as programming environments, design documents, and programming codes. These software artifacts can be studied and improved based on usability and User eXperience (UX) factors. In this paper, we consider programmers to be a specific case of users and analyze different elements that influence their experience in this specific context. We conducted a systematic literature review of papers published over the last ten years related to 1) the definition of the Programmer eXperience (PX); 2) the PX, UX, and usability factors regarding the programming environments, design documents, and programming codes; and 3) sets of heuristics to evaluate the software development artifacts mentioned before. We analyzed 73 articles, and the results obtained show that: 1) the important elements that influence the PX are the motivation of programmers and the choice of tools they use in their work, such as programming environments; 2) most of the identified studies (59\%) aimed to evaluate the influence of the PX, UX, and usability on programming environments; 3) the majority of the studies (70\%) used methods such as usability tests and/or heuristic evaluation methods; and 4) four sets of heuristics are used to evaluate software development artifacts in relation to programming environments, programming languages, and application programming interfaces. The results suggest that further research in this area is necessary to better understand and evaluate the concept of the PX.},
	journal = {IEEE Access},
	author = {Morales, Jenny and Rusu, Cristian and Botella, Federico and Quiñones, Daniela},
	year = {2019},
	note = {Conference Name: IEEE Access},
	keywords = {User experience, Bibliographies, Heuristic evaluation, Programmer eXperience, Programming, Programming environments, systematic literature review, Systematics, usability, Usability, User eXperience},
	pages = {71079--71094},
	file = {IEEE Xplore Full Text PDF:/home/hannah/Zotero/storage/VZQ4KSP2/Morales et al. - 2019 - Programmer eXperience A Systematic Literature Rev.pdf:application/pdf},
}

@inproceedings{fagerholm_developer_2012,
	title = {Developer experience: {Concept} and definition},
	shorttitle = {Developer experience},
	doi = {10.1109/ICSSP.2012.6225984},
	abstract = {New ways of working such as globally distributed development or the integration of self-motivated external developers into software ecosystems will require a better and more comprehensive understanding of developers' feelings, perceptions, motivations and identification with their tasks in their respective project environments. User experience is a concept that captures how persons feel about products, systems and services. It evolved from disciplines such as interaction design and usability to a much richer scope that includes feelings, motivations, and satisfaction. Similarly, developer experience could be defined as a means for capturing how developers think and feel about their activities within their working environments, with the assumption that an improvement of the developer experience has positive impacts on characteristics such as sustained team and project performance. This article motivates the importance of developer experience, sketches related approaches from other domains, proposes a definition of developer experience that is derived from similar concepts in other domains, describes an ongoing empirical study to better understand developer experience, and finally gives an outlook on planned future research activities.},
	booktitle = {2012 {International} {Conference} on {Software} and {System} {Process} ({ICSSP})},
	author = {Fagerholm, Fabian and Münch, Jürgen},
	month = jun,
	year = {2012},
	keywords = {Software, Software engineering, Programming, Developer experience, high-performing teams, human factors, Human factors, Humans, Integrated circuit modeling, Productivity, software development environment, software psychology},
	pages = {73--77},
	file = {Accepted Version:/home/hannah/Zotero/storage/B2MHXRQJ/Fagerholm and Münch - 2012 - Developer experience Concept and definition.pdf:application/pdf;IEEE Xplore Abstract Record:/home/hannah/Zotero/storage/YJGUYMZ2/6225984.html:text/html},
}

@phdthesis{levlin_dom_2020,
	title = {{DOM} benchmark comparison of the front-end {JavaScript} frameworks {React}, {Angular}, {Vue}, and {Svelte}},
	copyright = {Julkaisu on tekijänoikeussäännösten alainen. Teosta voi lukea ja tulostaa henkilökohtaista käyttöä varten. Käyttö kaupallisiin tarkoituksiin on kielletty.},
	url = {https://www.doria.fi/handle/10024/177433},
	abstract = {One of the most used tools for creating interactive, advanced, and easily maintainable websites in 2020 is the programming language JavaScript. Over the last decade, many front-end frameworks have been built on top of JavaScript, which makes creation, design, and maintenance of interactive websites easier. As of 2020, the most popular front-end JavaScript frameworks were, by a large margin, React and Vue, followed by Angular. A relatively new framework called Svelte was also gaining in popularity and raised developer interest. This study will evaluate the performance of these front-end JavaScript frameworks. The criteria for evaluation are primarily based on speed of completing certain operations related to DOM elements in the web browser, such as DOM element addition, editing, and removal. Non-technical evaluation points include differences in architecture, development experience, popularity, maturity, and availability.

To set the context for the study of these frameworks, the study begins with an outline of the history and development of JavaScript. Its current status and versions are also described. Surrounding technologies relevant to the study are presented, such as DOM and HTML. Following this, the key features of front-end JavaScript frameworks are investigated, and the development setup process for a generic framework is documented. The criteria for selecting frameworks for evaluation is presented, and the four selected front-end frameworks are then investigated and evaluated. A benchmark JavaScript application is described and created for each of the frameworks. With this reference application, a number of technical benchmarks are performed, where the frameworks are rated according to how well they perform various DOM data updates. Finally, a recommendation is made on which frameworks are best suited for use, and how the future landscape of front-end JavaScript frameworks is likely to develop.},
	author = {Levlin, Mattias},
	year = {2020},
	file = {Full Text PDF:/home/hannah/Zotero/storage/75C6V459/Levlin - 2020 - DOM benchmark comparison of the front-end JavaScri.pdf:application/pdf},
}

@article{ollila_modern_2022,
	title = {Modern {Web} {Frameworks} : {A} {Comparison} of {Rendering} {Performance}},
	copyright = {info:eu-repo/semantics/openAccess},
	shorttitle = {Modern {Web} {Frameworks}},
	url = {https://helda.helsinki.fi/handle/10138/343674},
	abstract = {Recent years have seen the rise of a new generation of UI frameworks for web application development. These frameworks differ from previous generations of JavaScript frameworks in that they define a declarative application development model, where transitions in the state of the UI are managed by the framework. This potentially greatly simplifies application development, but requires the framework to implement a rendering strategy which translates changes in application state into changes in the state of the UI. The performance characteristics of these rendering strategies have thus far been poorly studied. In this article, we describe the rendering strategies used in the frameworks Angular, React, Vue, Svelte and Blazor, which represent some of the most influential and widely used modern web frameworks. We find significant differences in the scaling of costs in their rendering strategies with potentially equally significant practical performance implications. To verify these differences, we implement a number of benchmarks that measure the scaling of rendering costs as an application grows in complexity. The results of our benchmarks confirm that under certain circumstances, performance differences between frameworks can range up to several orders of magnitude when performing the same tasks. Furthermore, we find that the relative performance of a rendering strategy can be effectively estimated based on factors affecting the input sizes of render loops. The best performing rendering strategies are found to be ones which minimize input sizes using techniques such as compile-time optimization and reactive programming models.},
	language = {eng},
	urldate = {2023-02-07},
	author = {Ollila, Risto and Mäkitalo, Niko and Mikkonen, Tommi},
	year = {2022},
	note = {Accepted: 2022-05-13T05:49:06Z},
	file = {Full Text PDF:/home/hannah/Zotero/storage/9AGCMKF6/Ollila et al. - 2022 - Modern Web Frameworks  A Comparison of Rendering .pdf:application/pdf},
}

@article{vainikka_full-stack_nodate,
	title = {Full-stack web development using {Django} {REST} framework and {React}},
	language = {en},
	author = {Vainikka, Joel},
	file = {Vainikka - Full-stack web development using Django REST frame.pdf:/home/hannah/Zotero/storage/TAJM8DHR/Vainikka - Full-stack web development using Django REST frame.pdf:application/pdf},
}

@misc{noauthor_realworld_2023,
	title = {Realworld {App}},
	copyright = {MIT},
	url = {https://github.com/gothinkster/realworld},
	abstract = {"The mother of all demo apps" — Exemplary fullstack Medium.com clone powered by React, Angular, Node, Django, and many more},
	urldate = {2023-06-02},
	publisher = {Thinkster},
	month = jun,
	year = {2023},
	note = {original-date: 2016-02-26T20:49:53Z},
}

@misc{acmion_sveltescaling_2023,
	title = {{SvelteScaling}},
	copyright = {MIT},
	url = {https://github.com/Acmion/SvelteScaling},
	abstract = {Does Svelte scale?},
	urldate = {2023-05-04},
	author = {Acmion},
	month = apr,
	year = {2023},
	note = {original-date: 2020-08-29T20:51:43Z},
	keywords = {analysis, javascript, react, scalability, spa, svelte},
}

@misc{noauthor_understanding_2021,
	title = {Understanding {Transitional} {JavaScript} {Apps}},
	url = {https://dev.to/this-is-learning/understanding-transitional-javascript-apps-27i2},
	abstract = {Transitional JavaScript Apps? What? Well honestly I'm not sure I know completely myself. It is an...},
	language = {en},
	urldate = {2023-04-18},
	journal = {DEV Community},
	month = nov,
	year = {2021},
	file = {Snapshot:/home/hannah/Zotero/storage/WIR9GSVP/understanding-transitional-javascript-apps-27i2.html:text/html},
}

@misc{macwright_second-guessing_nodate,
	title = {Second-guessing the modern web},
	url = {https://macwright.com/2020/05/10/spa-fatigue.html},
	abstract = {What if everyone's wrong?},
	language = {en},
	urldate = {2023-04-18},
	journal = {macwright.com},
	author = {MacWright, Tom},
	file = {Snapshot:/home/hannah/Zotero/storage/HDSW9GHJ/spa-fatigue.html:text/html},
}

@misc{noauthor_solving_2018,
	title = {Solving the {N}+1 {Problem} for {GraphQL} through {Batching}},
	url = {https://shopify.engineering/solving-the-n-1-problem-for-graphql-through-batching},
	abstract = {Authors: Leanne Shapton, Dylan Thacker-Smith, \&amp; Scott Walkinshaw
When Shopify merchants build their businesses on our platform, they trust that we’ll provide them with a seamless experience. A huge part of that is creating scalable back-end solutions that allow us to manage the millions of requests reaching our servers each day.
When a storefront app makes a request to our servers, they’re interacting with the Storefront API. Historically, REST is the language of choice when designing...},
	language = {en},
	urldate = {2023-04-18},
	journal = {Shopify},
	month = apr,
	year = {2018},
	file = {Snapshot:/home/hannah/Zotero/storage/4LZDQHQL/solving-the-n-1-problem-for-graphql-through-batching.html:text/html},
}

@misc{greif_state_2022,
	title = {State of {JavaScript} 2022},
	url = {https://2022.stateofjs.com/en-US/},
	abstract = {The 2022 edition of the annual survey about the latest trends in the JavaScript ecosystem.},
	language = {en},
	urldate = {2023-04-11},
	author = {Greif, Sacha and Burel, Eric},
	year = {2022},
	file = {Snapshot:/home/hannah/Zotero/storage/XCABURJK/en-US.html:text/html},
}

@misc{noauthor_monorepo_nodate,
	title = {Monorepo {Explained}},
	url = {https://monorepo.tools/},
	abstract = {Everything you need to know about monorepos, and the tools to build them.},
	language = {en},
	urldate = {2023-03-11},
	journal = {monorepo.tools},
	file = {Snapshot:/home/hannah/Zotero/storage/5T88BH4B/monorepo.tools.html:text/html},
}

@misc{jamstack_tv_have_2021,
	title = {Have {Single}-{Page} {Apps} {Ruined} the {Web}? {\textbar} {Transitional} {Apps} with {Rich} {Harris}, {NYTimes}},
	shorttitle = {Have {Single}-{Page} {Apps} {Ruined} the {Web}?},
	url = {https://www.youtube.com/watch?v=860d8usGC0o},
	abstract = {The backlash to modern front end development is gaining steam, with good reason: single-page apps have ruined the web. Can we rescue it without going backwards? In this talk, Rich Harris presents a way to do just that. Rich Harris is a graphics editor at the New York Times, where he builds JavaScript apps to help explain the news. He is also the creator of Rollup, the JavaScript module bundler, and Svelte, the front end framework.

What’s wrong with Single-Page apps? There are a lot of critiques. A non-exhaustive list of terrible things about single-page apps include: 
You’ll need a bloated JavaScript framework and performance will suffer
It comes with complex tooling and is less resilient, since it won’t work without JavaScript 
It will be buggy and accessibility issues

JavaScript failing is a fact of life. So what’s a developer to do? SPAs solve problems to the traditional approach, but are still problematic. Rich presents a new framework for thinking about how we can get the best of both the MPA and SPA worlds: transitional apps. 

What’s a transitional app? Transitional apps samples elements from both traditional and modern architecture. The term is borrowed from interior design’s framing of “transitional design.” Transitional apps are, like multi-page apps, server-side rendered for fast initial loads, resilient since they work without JS by default, and provide a consistent experience with accessibility features built in. But like a single-page application, they also have a single codebase, fast navigation, persistent elements, and client-side state management. 

Learn more about transitional apps, and how to get the best of both worlds in Rich’s talk.

Jamstack Conf is hosted by Netlify, a platform to build, run and scale modern web apps https://www.netlify.com
https://www.jamstackconf.com},
	urldate = {2023-03-07},
	author = {{Jamstack TV}},
	month = oct,
	year = {2021},
}

@misc{noauthor_everyone_nodate,
	title = {Everyone has {JavaScript}, right?},
	url = {https://www.kryogenix.org/code/browser/everyonehasjs.html},
	urldate = {2023-03-07},
	file = {Everyone has JavaScript, right?:/home/hannah/Zotero/storage/SQ9QB6SC/everyonehasjs.html:text/html},
}

@misc{harris_svelte_2019,
	title = {Svelte 3: {Rethinking} reactivity},
	shorttitle = {Svelte 3},
	url = {https://svelte.dev/blog/svelte-3-rethinking-reactivity},
	abstract = {It's finally here},
	language = {en},
	urldate = {2023-03-07},
	author = {Harris, Rich},
	month = apr,
	year = {2019},
	annote = {Rich Harris - Rethinking reactivity
},
}

@misc{harris_virtual_2018,
	title = {Virtual {DOM} is pure overhead},
	url = {https://svelte.dev/blog/virtual-dom-is-pure-overhead},
	abstract = {Let's retire the 'virtual DOM is fast' myth once and for all},
	language = {en},
	urldate = {2023-03-07},
	author = {Harris, Rich},
	month = dec,
	year = {2018},
}

@misc{team_announcing_2022,
	title = {Announcing {SvelteKit} 1.0},
	url = {https://svelte.dev/blog/announcing-sveltekit-1.0},
	abstract = {Web development, streamlined},
	language = {en},
	urldate = {2023-03-07},
	author = {team, The Svelte},
	month = dec,
	year = {2022},
}

@misc{noauthor_announcing_nodate,
	title = {Announcing {SvelteKit} {Auth}: {Bringing} {NextAuth}.js to all frameworks – {Vercel}},
	shorttitle = {Announcing {SvelteKit} {Auth}},
	url = {https://vercel.com/blog/announcing-sveltekit-auth},
	abstract = {SvelteKit Auth is a simple, low configuration authentication library for SvelteKit applications, with support for many popular OAuth providers.},
	language = {en},
	urldate = {2023-03-07},
}

@article{jadhav_framework_2011,
	title = {Framework for evaluation and selection of the software packages: {A} hybrid knowledge based system approach},
	volume = {84},
	issn = {0164-1212},
	shorttitle = {Framework for evaluation and selection of the software packages},
	url = {https://www.sciencedirect.com/science/article/pii/S016412121100077X},
	doi = {10.1016/j.jss.2011.03.034},
	abstract = {Evaluation and selection of the software packages is complicated and time consuming decision making process. Selection of inappropriate software package can turn out to be costly and adversely affects business processes and functioning of the organization. In this paper we describe (i) generic methodology for software selection, (ii) software evaluation criteria, and (iii) hybrid knowledge based system (HKBS) approach to assist decision makers in evaluation and selection of the software packages. The proposed HKBS approach employs an integrated rule based and case based reasoning techniques. Rule based reasoning is used to capture user needs of the software package and formulate a problem case. Case based reasoning is used to retrieve and compare candidate software packages with the user needs of the package. This paper also evaluates and compares HKBS approach with the widely used existing software evaluation techniques such as analytic hierarchy process (AHP) and weighted scoring method (WSM).},
	language = {en},
	number = {8},
	urldate = {2023-07-19},
	journal = {Journal of Systems and Software},
	author = {Jadhav, Anil S. and Sonar, Rajendra M.},
	month = aug,
	year = {2011},
	keywords = {Knowledge based system, Software evaluation, Software selection},
	pages = {1394--1407},
	file = {ScienceDirect Full Text PDF:/home/hannah/Zotero/storage/YS8BKZYD/Jadhav and Sonar - 2011 - Framework for evaluation and selection of the soft.pdf:application/pdf;ScienceDirect Snapshot:/home/hannah/Zotero/storage/ZQ9MB49T/S016412121100077X.html:text/html},
}

@article{manikas_software_2013,
	title = {Software ecosystems – {A} systematic literature review},
	volume = {86},
	issn = {0164-1212},
	url = {https://www.sciencedirect.com/science/article/pii/S016412121200338X},
	doi = {10.1016/j.jss.2012.12.026},
	abstract = {A software ecosystem is the interaction of a set of actors on top of a common technological platform that results in a number of software solutions or services. Arguably, software ecosystems are gaining importance with the advent of, e.g., the Google Android, Apache, and Salesforce.com ecosystems. However, there exists no systematic overview of the research done on software ecosystems from a software engineering perspective. We performed a systematic literature review of software ecosystem research, analyzing 90 papers on the subject taken from a gross collection of 420. Our main conclusions are that while research on software ecosystems is increasing (a) there is little consensus on what constitutes a software ecosystem, (b) few analytical models of software ecosystems exist, and (c) little research is done in the context of real-world ecosystems. This work provides an overview of the field, while identifying areas for future research.},
	language = {en},
	number = {5},
	urldate = {2023-07-19},
	journal = {Journal of Systems and Software},
	author = {Manikas, Konstantinos and Hansen, Klaus Marius},
	month = may,
	year = {2013},
	keywords = {Software ecosystem, Software ecosystems, Systematic literature review},
	pages = {1294--1306},
}

@article{runeson_guidelines_2009,
	title = {Guidelines for conducting and reporting case study research in software engineering},
	volume = {14},
	issn = {1573-7616},
	url = {https://doi.org/10.1007/s10664-008-9102-8},
	doi = {10.1007/s10664-008-9102-8},
	abstract = {Case study is a suitable research methodology for software engineering research since it studies contemporary phenomena in its natural context. However, the understanding of what constitutes a case study varies, and hence the quality of the resulting studies. This paper aims at providing an introduction to case study methodology and guidelines for researchers conducting case studies and readers studying reports of such studies. The content is based on the authors’ own experience from conducting and reading case studies. The terminology and guidelines are compiled from different methodology handbooks in other research domains, in particular social science and information systems, and adapted to the needs in software engineering. We present recommended practices for software engineering case studies as well as empirically derived and evaluated checklists for researchers and readers of case study research.},
	language = {en},
	number = {2},
	urldate = {2023-07-04},
	journal = {Empirical Software Engineering},
	author = {Runeson, Per and Höst, Martin},
	month = apr,
	year = {2009},
	keywords = {Case study, Checklists, Guidelines, Research methodology},
	pages = {131--164},
	file = {Full Text PDF:/home/hannah/Zotero/storage/FZBWDHM5/Runeson and Höst - 2009 - Guidelines for conducting and reporting case study.pdf:application/pdf},
}

@misc{offerzen_origins_svelte_2022,
	title = {Svelte {Origins}: {A} {JavaScript} {Documentary}},
	shorttitle = {Svelte {Origins}},
	url = {https://www.youtube.com/watch?v=kMlkCYL9qo0},
	abstract = {🎥 More tech documentaries coming out soon, subscribe to be notified 👉

(PS: The 2022 Stack Overflow Developer Survey results just came out and Phoenix overtook Svelte as the world's most loved web framework so hey, we had to adjust our thumbnail a bit 🤷)

Svelte Origins: The Documentary tells the story of how Svelte came to be, what makes Svelte different, and how it changes the game as a JavaScript framework. Filmed in locations throughout Europe and the US, it features Svelte’s creator Rich Harris and members from the core community who contributed to making Svelte what it is today.

Svelte Origins was filmed in late 2021, produced by OfferZen and directed by Dewald Brand, with shoots in the USA, the UK, Ireland, Sweden and Germany.

0:27 Who is Rich Harris?
0:52 Why is Svelte called Svelte?
1:39 What is Svelte?
1:52 How does Svelte differ from other JS frameworks like React or Vue?
2:50 How did Rich Harris get into tech?
4:38 Visual journalism and the creation of Ractive.js
5:43 Why did Rich Harris create Svelte?
6:57 Core Svelte contributors
7:44 Ben McCann talks about reactive code
8:50 How Svelte went from V1 to V3
10:09 Scott Tolinski explains what makes Svelte so appealing to many JS developers
12:41 Amelia Wattenberger talks about Svelte being the JS framework with the highest satisfaction rates
14:50 Aliza Aufrichtig talks about using Svelte at the New York Times
17:22 Moritz Stefaner talks about building the German vaccination dashboard using Svelte
19:05 Rich Harris explains that Svelte is as generic and flexible a JS framework as React or Vue
19:43 TypeScript support was one of the most popular requested features in Svelte
20:47 Orta Therox explains why \& how TypeScript support was brought into Svelte
22:40 Introducing Svelte Summit and the Svelte community
23:58 Swyx, Antony Jones and Kevin A.K. talk about the origin story behind Svelte Society and its purpose in the Svelte ecosystem
27:46 Rich Harris and Guillermo Rauch (CEO of Vercel \& creator of Next.js) talk about Rich Harris joining Vercel and what this means for Svelte
30:26 Rich Harris reflects on the success of Svelte and what the future might look like

\#svelte \#sveltejs \#javascript \#typescript \#react \#vue \#nextjs \#vercel

OfferZen is a developer job platform helping devs find jobs they love in positions they deserve. Want to know more about OfferZen? Check out the link below. 👇 

https://bit.ly/dev-jobs-sdo

Connect with OfferZen:
Twitter: https://twitter.com/offerZen/
Instagram: https://www.instagram.com/offerzen/
Facebook: https://www.facebook.com/offerzen/
LinkedIn: https://www.linkedin.com/company/offe...},
	urldate = {2023-08-15},
	author = {{OfferZen Origins}},
	month = jun,
	year = {2022},
}

@article{bialecki_performance_2021,
	title = {Performance analysis of {Svelte} and {Angular} applications},
	volume = {19},
	copyright = {Copyright (c) 2021 Gabriel Białecki, Beata Pańczyk},
	issn = {2544-0764},
	url = {https://ph.pollub.pl/index.php/jcsi/article/view/2633},
	doi = {10.35784/jcsi.2633},
	abstract = {The aim of this article is to check if the Svelte-based client part of a web application is more effective than the standard Angular approach. The article presents a comparison of page components rendering times on the basis of two test applications prepared in both frameworks. For the performance tests, scenarios were prepared in which the times of adding and removing a different number of page components were examined. Application tests were performed using the Selenium Webdriver package. The research results clearly showed that the new approach used for DOM manipulation (Svelte v.3.0) is more efficient than the standard solution used in Angular applications (v.10.2).},
	language = {en},
	urldate = {2023-08-17},
	journal = {Journal of Computer Sciences Institute},
	author = {Białecki, Gabriel and Pańczyk, Beata},
	month = jun,
	year = {2021},
	keywords = {Angular, Svelte, frontend, performance},
	pages = {139--143},
	file = {Full Text PDF:/home/hannah/Zotero/storage/DWV936HB/Białecki and Pańczyk - 2021 - Performance analysis of Svelte and Angular applica.pdf:application/pdf},
}

@phdthesis{klimm_design_2021,
	title = {Design {Systems} for {Micro} {Frontends} - {An} {Investigation} into the {Development} of {Framework}-{Agnostic} {Design} {Systems} using {Svelte} and {Tailwind} {CSS}},
	copyright = {https://creativecommons.org/licenses/by-sa/4.0/deed.de},
	url = {https://epb.bibl.th-koeln.de/frontdoor/index/index/docId/1666},
	abstract = {This bachelor thesis deals with framework-agnostic design systems in the environment of micro frontends. The properties of micro frontends and design systems are developed individually, to finally get combined. Important disciplines of this research are in particular cybernetics and system thinking, whereby further properties in the relationships between the stakeholders and the design system are highlighted and defined. In addition, based on the highlighted properties, a practically oriented evaluation is prepared, which demonstratively verifies how framework-agnostic design systems can be realized using Svelte and Tailwind CSS. The insights gained from this work can be used for further considerations in other works within the domain, or similar domains. In particular the cybernetic view of systematic design offers potential for further investigations.},
	language = {eng},
	urldate = {2023-08-17},
	school = {Hochschulbibliothek der Technischen Hochschule Köln},
	author = {Klimm, Marvin Christian},
	month = feb,
	year = {2021},
	file = {Full Text PDF:/home/hannah/Zotero/storage/VRMQ8C5Q/Klimm - 2021 - Design Systems for Micro Frontends - An Investigat.pdf:application/pdf},
}

@misc{noauthor_declarative_2023,
	title = {Declarative {Shadow} {DOM}},
	url = {https://developer.chrome.com/articles/declarative-shadow-dom/},
	abstract = {Declarative Shadow DOM is a new way to implement and use Shadow DOM directly in HTML.},
	language = {en},
	urldate = {2023-08-28},
	journal = {Chrome Developers},
	month = feb,
	year = {2023},
	file = {Snapshot:/home/hannah/Zotero/storage/7BYXVZD4/declarative-shadow-dom.html:text/html},
}

@misc{noauthor_prisma_nodate,
	title = {Prisma {\textbar} {Next}-generation {ORM} for {Node}.js \& {TypeScript}},
	url = {https://www.prisma.io},
	abstract = {Prisma is a next-generation Node.js and TypeScript ORM for PostgreSQL, MySQL, SQL Server, SQLite, MongoDB, and CockroachDB. It provides type-safety, automated migrations, and an intuitive data model.},
	language = {en},
	urldate = {2023-08-24},
	journal = {Prisma},
	file = {Snapshot:/home/hannah/Zotero/storage/2GSRPYAI/www.prisma.io.html:text/html},
}

@misc{noauthor_definition_nodate,
	title = {Definition of {Enterprise} {Applications} - {Gartner} {Information} {Technology} {Glossary}},
	url = {https://www.gartner.com/en/information-technology/glossary/enterprise-applications},
	abstract = {Enterprise applications are designed to integrate computer systems that run all phases of an enterprise’s operations to facilitate cooperation and coordination of work across the enterprise.},
	language = {en},
	urldate = {2023-09-27},
	journal = {Gartner},
	file = {Snapshot:/home/hannah/Zotero/storage/LS2QCEU3/enterprise-applications.html:text/html},
}

@misc{noauthor_what_nodate,
	title = {What is {Enterprise} {Software}? - {Everything} you need to know - {AWS}},
	shorttitle = {What is {Enterprise} {Software}?},
	url = {https://aws.amazon.com/what-is/enterprise-software/},
	abstract = {Find out what Enterprise Software is, why is it necessary and best practices.},
	language = {en-US},
	urldate = {2023-09-27},
	journal = {Amazon Web Services, Inc.},
	file = {Snapshot:/home/hannah/Zotero/storage/P8QRN3H2/enterprise-software.html:text/html},
}

@misc{beal_what_2010,
	title = {What is {An} {Enterprise} {Application}?},
	url = {https://www.webopedia.com/definitions/enterprise-application/},
	abstract = {The enterprise application is a cornerstone of a business's ability to operate online. Learn all about enterprise applications with our definition.},
	language = {en-US},
	urldate = {2023-09-27},
	journal = {Webopedia},
	author = {Beal, Vangie},
	month = may,
	year = {2010},
	file = {Snapshot:/home/hannah/Zotero/storage/UGQATAJL/enterprise-application.html:text/html},
}

@misc{noauthor_expose_nodate,
	title = {Expose a way to inject middleware in the server pipeline for adapt-node · {Issue} \#334 · sveltejs/kit},
	url = {https://github.com/sveltejs/kit/issues/334},
	abstract = {Similar to \#333 It would be valuable to be able to insert additional handlers in the adapt-node server pipeline to customize the serving behavior based on deployment env. https://github.com/sveltej...},
	language = {en},
	urldate = {2023-09-28},
	journal = {GitHub},
	annote = {I feel like we need to be specific about the use cases here. The downside of a catch-all escape hatch is that it means that the answer to various problems becomes 'use adapter-node, because you can use arbitrary middleware' which is the opposite of what we want out of a serverless framework. I think it would be better to be able to satisfy those uses across different adapters, but it's hard to know what the relevant APIs look like unless we have a clear handle on what those uses are
},
	file = {Snapshot:/home/hannah/Zotero/storage/MJNSEHZE/334.html:text/html},
}

@misc{noauthor_vercel_nodate,
	title = {Do {Vercel} {Serverless} {Functions} support {WebSocket} connections?},
	url = {https://vercel.com/guides/do-vercel-serverless-functions-support-websocket-connections},
	abstract = {Information on Vercel's support for WebSocket connections with Serverless Functions.},
	language = {en},
	urldate = {2023-09-28},
	journal = {Vercel Documentation},
	file = {Snapshot:/home/hannah/Zotero/storage/5NA8PXNM/do-vercel-serverless-functions-support-websocket-connections.html:text/html},
}

@misc{team_introducing_2023,
	title = {Introducing runes},
	url = {https://svelte.dev/blog/runes},
	abstract = {Rethinking 'rethinking reactivity'},
	language = {en},
	urldate = {2023-09-29},
	author = {team, The Svelte},
	month = sep,
	year = {2023},
	file = {Snapshot:/home/hannah/Zotero/storage/IJLZNHJQ/runes.html:text/html},
}

@misc{noauthor_sveltekit_nodate,
	title = {{SvelteKit} • {Web} development, streamlined},
	url = {https://kit.svelte.dev/},
	abstract = {SvelteKit is the official Svelte application framework},
	language = {en},
	urldate = {2023-09-30},
	file = {Snapshot:/home/hannah/Zotero/storage/QKLBQPJI/kit.svelte.dev.html:text/html},
}

@misc{noauthor_webdev_nodate,
	title = {web.dev},
	url = {https://web.dev/},
	language = {en},
	urldate = {2023-10-09},
	journal = {web.dev},
	file = {Snapshot:/home/hannah/Zotero/storage/KVVS893B/web.dev.html:text/html},
}

@article{bainomugisha_survey_2013,
	title = {A survey on reactive programming},
	volume = {45},
	issn = {0360-0300},
	url = {https://dl.acm.org/doi/10.1145/2501654.2501666},
	doi = {10.1145/2501654.2501666},
	abstract = {Reactive programming has recently gained popularity as a paradigm that is well-suited for developing event-driven and interactive applications. It facilitates the development of such applications by providing abstractions to express time-varying values and automatically managing dependencies between such values. A number of approaches have been recently proposed embedded in various languages such as Haskell, Scheme, JavaScript, Java, .NET, etc. This survey describes and provides a taxonomy of existing reactive programming approaches along six axes: representation of time-varying values, evaluation model, lifting operations, multidirectionality, glitch avoidance, and support for distribution. From this taxonomy, we observe that there are still open challenges in the field of reactive programming. For instance, multidirectionality is supported only by a small number of languages, which do not automatically track dependencies between time-varying values. Similarly, glitch avoidance, which is subtle in reactive programs, cannot be ensured in distributed reactive programs using the current techniques.},
	number = {4},
	urldate = {2023-10-12},
	journal = {ACM Computing Surveys},
	author = {Bainomugisha, Engineer and Carreton, Andoni Lombide and Cutsem, Tom van and Mostinckx, Stijn and Meuter, Wolfgang de},
	month = aug,
	year = {2013},
	keywords = {dataflow programming, event-driven applications, functional reactive programming, interactive applications, Reactive programming, reactive systems},
	pages = {52:1--52:34},
	file = {Full Text PDF:/home/hannah/Zotero/storage/656NUNIY/Bainomugisha et al. - 2013 - A survey on reactive programming.pdf:application/pdf},
}

@misc{occhino_js_2013,
	title = {{JS} {Apps} at {Facebook}},
	url = {https://www.youtube.com/watch?v=GW0rj4sNH2w},
	urldate = {2023-10-12},
	author = {Occhino, Tom and Walke, Jordan},
	month = aug,
	year = {2013},
	file = {[JSConfUS 2013] Tom Occhino and Jordan Walke\: JS Apps at Facebook - YouTube:/home/hannah/Zotero/storage/TE3XD6W3/watch.html:text/html},
}

@misc{noauthor_proposal_nodate,
	title = {[{Proposal}] {Run} js expressions in markup template through {Svelte} script preprocessor code · {Issue} \#4701 · sveltejs/svelte},
	url = {https://github.com/sveltejs/svelte/issues/4701},
	urldate = {2023-10-12},
	file = {[Proposal] Run js expressions in markup template through Svelte script preprocessor code · Issue #4701 · sveltejs/svelte:/home/hannah/Zotero/storage/XIS52UTY/4701.html:text/html},
}

@misc{noauthor_load_nodate,
	title = {Load time to conversion statistics},
	url = {https://www.thinkwithgoogle.com/marketing-strategies/app-and-mobile/load-time-to-conversion-statistics/},
	abstract = {Did you know that a 1-second delay in load time can impact conversion by up to 20\% in retail. Discover more conversion data on Think with Google.},
	language = {en},
	urldate = {2023-10-23},
	journal = {Think with Google},
	file = {Snapshot:/home/hannah/Zotero/storage/LQMBMGP5/load-time-to-conversion-statistics.html:text/html},
}

@online{kurz_brief_2020,
	title = {A Brief History of {OpenUI}5 (and {SAPUI}5) {\textbar} {SAP} Blogs},
	url = {https://blogs.sap.com/2020/11/04/a-brief-history-of-openui5-and-sapui5/},
	author = {Kurz, Andread},
	urldate = {2023-10-24},
	date = {2020-11-04},
	file = {A Brief History of OpenUI5 (and SAPUI5) | SAP Blogs:C\:\\Users\\hlappe\\Zotero\\storage\\8SBGW93G\\a-brief-history-of-openui5-and-sapui5.html:text/html},
}

@online{kunz_what_2013,
	title = {What is {OpenUI}5 / {SAPUI}5 ? {\textbar} {SAP} Blogs},
	url = {https://blogs.sap.com/2013/12/11/what-is-openui5-sapui5/},
	author = {Kunz, Andreas},
	urldate = {2023-10-24},
	date = {2013-12-11},
	file = {What is OpenUI5 / SAPUI5 ? | SAP Blogs:C\:\\Users\\hlappe\\Zotero\\storage\\X8IU7U5V\\what-is-openui5-sapui5.html:text/html},
}
