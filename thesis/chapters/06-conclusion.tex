\chapter{Conclusion and Future Work}
\label{ch:conclusion}

% \todo{Write whole chapter}

% Main takeaways:
% \begin{itemize}
%   \item very fast to set up and deploy project, thanks to create script and adapters
%   \item Fast dev Cycle, especially for small projects. 
%   \item Router and simple API make for very fast development cycle.
%   \item But, many Svelte features not usable with Components
%   \item Language is still moving very fast
% \end{itemize}

% Future work:
% \begin{itemize}
%   \item Develop robust and scalable project best practices
% \end{itemize}

In this work we investigated SvelteKit's applicability for the development of enterprise applications. To this end, we chose a business application used productively in a real-world scenario. We reimplemented this application in SvelteKit using a full stack, single-page application, and a frontend only approach. Furthermore, we compared the existing implementation, written in UI5 and Java, with our SvelteKit implementations in terms of performance and development effort. Finally, we provided insights into SvelteKit which can help in making future technology choices.

Our results show that all of our SvelteKit implementations performed significantly better in terms of page-load and navigation speed. Especially when used with server-side rendering, SvelteKit was able to achieve the fastest page load time. Notable outlier was the single page application variant that, while providing the fastest time to first byte, required the longest time out of the SvelteKit implementations to render any content to the screen. This is a result of SvelteKit's data fetching mechanism which is not suited for deferred rendering of content.

In terms of development effort our comparative analysis provides multiple examples where SvelteKit is expected to be easier to use. This is a result of Svelte's concise Syntax as well as feature-set which aims to ease declaration of user interfaces. Furthermore, Svelte's colocation between UI and controlling logic provided a clearer and easier to reason about system. Finally, Svelte's language tools provided better support for working with the language. Types are automatically inferred across most of SvelteKit's API's, making it easy to work with growing code bases. This is contrasted by UI5's vast set of features. Especially UI5's large component-library provides capabilities for many often required features such as analytical Tables. 

SvelteKit only recently reached its first stable release and is still being actively developed. This means that some key features such as native websocket and localization support are not provided yet. Furthermore, Svelte's development team has in the past not shied away from overhauling major parts of the language (\Cref{sec:evaluation-stability}). SvelteKit's library ecosystem also has not reached maturity. In our study we were not able to find a library that provided full out-of-the-box support for authentication through OIDC.

In our Opinion, SvelteKit makes it easy to develop custom UI-components. This makes SvelteKit especially suited for use-cases where a custom design system is desired, or pre-built components cannot satisfy all feature requirements. Furthermore, SvelteKit's flexible rendering model makes it suitable for small projects where it is feasible to colocate frontend and backend code, as well as larger projects with separated backend. When evaluating SvelteKit for a new project it furthermore has to be evaluated if SvelteKit's ecosystem provides mature solutions for the projects requirements.


Future work could further investigate SvelteKit's developer experience in the form of user surveys which was out of scope for this work. Furthermore, it is not clear how SvelteKit compares to contemporary meta frameworks, such as Next.js, Astro, and Remix. To this end, future work could compare SvelteKit to these frameworks. 

% Future work:
% \begin{itemize}
%   \item compare to contemporary frameworks e.g. Next.js, Remix, Qwik
%   \item User survey into developer experience.
% \end{itemize}