\chapter{Fundamentals}
\label{ch:fundamentals}

% todo: React Server Components

This Chapter introduces fundamental knowledge that will be required in the following thesis.


\section{Enterprise Applications}
\label{sec:enterprise-applications}

% Our applications usually not public facing $\rightarrow$ SEO not relevant $\rightarrow$ SSR, FCP, TTI not as relevant

% - few users up to thousands of users
% - multi-language support
% - stammdatenverwaltung
% - custom framework only relevant for use cases not satisfied by of the shelf software

An enterprise application is software which is used by companies, rather than individual users. Their purpose is to alleviate tasks commonly found in the management and organization process of an enterprise. Common tasks for enterprise applications can be:
\begin{itemize}
    \item enterprise communication
    \item business intelligence (BI)
    \item customer relationship management (CRM)
    \item human resource management (HRM)
    \item enterprise resource planning (ERP)
\end{itemize}

Requirements of an enterprise application can differ vastly depending on its use case, targeted user group, company size, company location, and scope \cite{noauthor_what_nodate,beal_what_2010}. While many ready-made software solutions exist which provide support for common tasks such as ERP, HRM, and CRM, it is often not possible to map all processes of an enterprise to an of-the-shelf component. To this end custom software is often required, which is specifically developed for the given use-case.


\section{Programmer Experience}


\section{Web Development}
\label{sec:web-development}

\subsection{Rendering Patterns}
\label{sec:rendering-patterns}

% \begin{itemize}
%     \item At first only static files
%     \item later SSR (PHP and stuff)
%     \item CSR with dominance of SPA's heralded by React
%     \item now step back to hybrid approach using SSR or SSG with client side hydration.
% \end{itemize}

The rendering of web pages has evolved significantly over the years, with various techniques emerging to enhance user experience. 

\subsubsection{Static HTML}
Static HTML represents the most basic form of web page rendering. In this approach, the entire HTML content is generated on the server and sent to the client as a complete document. Static HTML offers exceptional performance, as there is minimal processing required on the client and server side. However, it lacks dynamic content updates and interactivity, making it suitable primarily for simple, non-interactive websites.

\subsubsection{Server Side Rendering}
Server-side Rendering (SSR) involves rendering web pages on the server, where both HTML and initial data are generated. The server delivers a fully populated HTML page to the client, improving initial load times and SEO performance. SSR is well-suited for content-heavy and dynamic websites, as it combines good performance with dynamic data capabilities. However, it may still require additional client-side processing for interactive features.

\subsubsection{Client Side Rendering}
Client-side rendering (CSR) shifts the rendering process to the client's browser. Initially, the server sends a minimal HTML template and JavaScript code. The browser then takes responsibility for rendering and fetching data, making CSR ideal for highly interactive web applications. However, CSR can result in slower initial page load times and worse SEO due to delayed rendering and indexing.

\subsubsection{Static Side Generation}
Static side Generation (SSG) is a more extreme form of SSR. Instead of rendering the content when the page is requested, it is instead rendered when the site is initially built. This result in a page with similar performance to static HTML and therefore improved SEO. But, because the page has to be rebuilt, every time content should change, it is only usable for content that rarely changes. This approach also does not scale well with the amount of different pages, because for every page, a separate resource has to be generated.

\subsubsection{Hydration}
When server rendered or static web pages are sent to the client side they initially are not interactive beyond the scope of default HTML functionality. Hydration refers to the process of turning this "dumb" web page into a fully interactive client-side Application. With hydration an application can benefit from the fast render times and improved SEO of SSR and SSG, while simultaneously providing the user experience improvements of client-side applications.

\begin{figure}
    \centering
    \begin{sequencediagram}
      \newthread{A}{Client}{}
      \newinst[1]{B}{Server}{}
      \newinst[1]{C}{Database}{}
      \begin{call}{A}{visit /home}{B}{index.html}
      \end{call}
      \begin{call}{A}{request Data}{B}{}
        \begin{call}{B}{SELECT *}{C}{}
        \end{call}
      \end{call}
      \begin{callself}{A}{render data}{}
      \end{callself}
    \end{sequencediagram}

    \label{fig:timing-spa}
    \caption{Example load timing for an application using client-side rendering.}
\end{figure}

\subsection{Meta Frameworks}

\input{chapters/03-svelte.tex}

\section{Methodology}
\label{sec:methodology}

% This thesis follows the principles of an explorative case study as defined by P. Runeson and M. HÃ¶st\cite{runeson_guidelines_2009}. The Authors describe the Process as consisting of five steps:

% \begin{enumerate}
%     \item Case study Design: Objectives are defined, and the case study is planned.
%     \item Preparation for data collection: procedures and protocols for data collection are defined.
%     \item Collecting evidence: execution with data collection on the studied case.
%     \item Analysis of the collected data.
%     \item Reporting
% \end{enumerate}

% As defined in \ref{sec:purpose-of-this-study}, this study intents to provide evidence that points towards or against SvelteKit's applicability for the development of business applications.

% \subsection{Definition of Data Collection}
% \begin{enumerate}
%     \item Performance metrics
%     \item complexity metrics
% \end{enumerate}

% \subsection{Collection of evidence}

% Metrics applied to all implementations

As defined in \Cref{sec:problem-statement} it is unclear if SvelteKit's claimed benefits translate to the development of real-world applications. To this end, this Study tries to provide evidence that validates SvelteKit's claims. Furthermore, we tried to identify potential shortcomings in SvelteKit's design and feature set. We aim to create a knowledge base of SvelteKit's advantages ad disadvantages which can be used for future technology  choices.

Our primary methodology for achieving this goal involved gaining insights into how SvelteKit behaves in a real-world software project. Therefore, we decided to write an implementation for a real-world use-case existing in an enterprise in the industry. To this end, a project that already has an implementation, which is used in production, was chosen. This has two advantages. Firstly, this makes sure the chosen project is representative for a real-world scenario. Secondly, the existing implementation could serve as a comparison to the created SvelteKit implementation.

The chosen project had to satisfy multiple requirements:
\begin{itemize}
    \item It should have a component responsible for management of datasets.
    \item The application should require authentication.
    \item It should require database persistence.
    \item It should require communication with other services.  
    \item Furthermore, it should have at least one feature that goes beyond basic management of data.
\end{itemize}
These requirements where chosen to make sure the use-case is representative for a wide array of business applications. 

\subsection{Evaluation}

Factual evaluation:
\begin{enumerate}
    \item LoC
    \item performance
    \item ecosystem size
\end{enumerate}