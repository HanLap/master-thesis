
\chapter{Fundamentals}
\label{ch:fundamentals}

This Chapter introduces fundamental knowledge that will be required in the following thesis.


\section{Methodology}
\label{sec:methodology}

This thesis follows the principles of an explorative case study as defined by P. Runeson and M. HÃ¶st\cite{runeson_guidelines_2009}. The Authors describe the Process as consisting of five steps:

\begin{enumerate}
    \item Case study Design: Objectives are defined, and the case study is planned.
    \item Preparation for data collection: procedures and protocols for data collection are defined.
    \item Collecting evidence: execution with data collection on the studied case.
    \item Analysis of the collected data.
    \item Reporting
\end{enumerate}

As defined in \ref{sec:purpose-of-this-study}, this study intents to provide evidence that points towards or against SvelteKit's applicability for the development of business applications.

\subsection{Definition of Data Collection}
\begin{enumerate}
    \item Performance metrics
    \item complexity metrics
\end{enumerate}

\subsection{Collection of evidence}

Metrics applied to all implementations


\subsection{Evaluation}

Factual evaluation:
\begin{enumerate}
    \item LoC
    \item performance
    \item ecosystem size
\end{enumerate}

\section{Programmer Experience}


\section{Web Development}
\label{sec:web-development}

\subsection{History}

\subsection{Rendering Patterns}

\subsection{Meta Frameworks}

\section{Svelte}
\label{sec:svelte}
% - [ ] Svelte <span style="color: red">[important]</span> 14.8
% - [ ] What is Svelte
%     - [ ] origins
%     - [ ] created by Rich harris
%     - [ ] successor to Ractive.js
%     - [ ] most loved framework 2021
%     - [ ] compiler based approach
% - [ ] Features
%     - [ ] svelte files
%         - modified html
%         -  similar to vue3 because vue author inspired by svelte predecessor (source?)
%     - [ ] reactivity
%         - `$` to make statement reactive
%         - usual assignment operators to update
%         - possible because svelte uses compiler
%         - show example of generated code
%     - [ ] templating
%         - very simple
%         - if
%         - each
%     - [ ] events
%         - on:click
%     - [ ] bindings
%         -  bind:value
%     - [ ] components
%         - component syntax
%     - [ ] store
%     - [ ] scoped styling
%     - [ ] animations

% svelte is component library
% created by Rich Harris as successor to Ractive.js \cite{offerzen_origins_svelte_2022}
% 
% language for developing user interfaces on the web \cite{offerzen_origins_svelte_2022}
% 
% framework not something to run code but to think about code
% 
% tries to do as much as possible at build-time instead of runtime
% 
% compiler means it is possible to do things which would not work in vanilla JS

\section{Features}

\subsection{Svelte Files}
% - Files with .svelte ending
% - Syntax very similar to regular html with some extensions
% - standard javascript/Typescript $=>$ existing tools can be more easily integrated
% - javascript/html/css colocated in same file
% - {} to use js expressions in html, similar to react.
% - shorthand attribute syntax

\begin{minted}{html}
<script>
    let count = 2;
</script>

<div>count: {count}!</div>
\end{minted}

\subsection{Reactivity}
% - asignments with usual js asignments. would not work in React.
% - unlike react, svelte runs script just once, for assignments, svelte inserts invalidate blocks to update a variable
% - compare svelte to equivalent react code.

\begin{minted}[highlightlines={4-6,9}]{html}
<script>
    let count = 2;

    function increment() {
        count += 1;
    }
</script>

<button on:click="{increment}">click me!</button>
<div>count: {count}!</div>
\end{minted}

\begin{minted}{js}
function increment() {
    $$invalidate('count', count += 1)
}
\end{minted}

\begin{minted}{jsx}
function Component() {

    const [count, setCount] = useState(2);

    function increment() {
        setCount((c) => c + 1);
    }

    return <>
        <button onClick={increment}>click me!</button>
        <div>count: {count}!</div>
    </>
}
\end{minted}


\begin{minted}[highlightlines={4}]{html}
<script>
    let count = 2;

    $: doubled = count * 2;

    function increment() {
        count += 1;
    }
</script>

<button on:click="{increment}">click me!</button>
<div>count: {count}!</div>
<div>doubled: {doubled}!</div>
\end{minted}

% - $: to make reactive statement
% - repurpose of rarely used js feature
% - used for reactive assignments, conditions, and whole codeblocks
% - reactive block is rerun everytime a variable used inside the block changes

\subsection{Templates}

\begin{minted}[highlightlines={11-14}]{html}
<script>
    let count = 2;

    function increment() {
        count += 1;
    }
</script>

<button on:click="{increment}">click me!</button>
<div>count: {count}!</div>
{#if count > 9}
    <div>Vegeta what does the scouter say about his power level?</div>
    <div>It's over 9!!</div>
{/if}
\end{minted}


\subsection{Events}

\subsection{Bindings}

\subsection{Components}

\section{SvelteKit}
\label{sec:sveltekit}

In addition to Svelte's core functionality, the Svelte ecosystem has further expanded with the introduction of SvelteKit. Developed as an official framework for building web applications, SvelteKit builds upon the foundations of Svelte and provides additional features and tools that streamline the development process. By leveraging the power of Svelte's compilation-based approach, SvelteKit enhances developer productivity, scalability, and provides a cohesive framework for building robust web applications.

\subsection{Key Features of SvelteKit}

SvelteKit introduces several key features that extend the capabilities of Svelte and facilitate the development of complex web applications:

\subsubsection{Server-Side Rendering (SSR)}

One of the notable additions in SvelteKit is the built-in support for server-side rendering (SSR). SSR enables rendering components on the server, which can improve initial page load performance and enable search engine crawlers to index content more effectively. SvelteKit seamlessly handles the rendering process on the server, allowing developers to build dynamic and interactive applications while benefiting from the performance advantages of SSR.

\subsubsection{Routing and Navigation}

SvelteKit provides a powerful routing system that enables developers to define and manage application routes effortlessly. The framework supports both client-side and server-side routing, allowing for smooth navigation between pages while preserving SEO benefits through SSR. SvelteKit's routing capabilities include dynamic routes, nested routes, and route guards, empowering developers to create sophisticated navigation structures.

\subsubsection{Built-In Data Fetching}

Fetching and managing data is a fundamental aspect of web application development. SvelteKit simplifies this process by offering built-in data fetching capabilities. Developers can easily define data dependencies for each page or component, and SvelteKit handles the data retrieval and synchronization. This feature streamlines the development workflow, reduces boilerplate code, and ensures optimal data fetching strategies, such as parallel or sequential requests, based on the application's needs.

\subsubsection{Preloading and Prefetching}

To optimize the user experience, SvelteKit provides preloading and prefetching mechanisms. Preloading allows the framework to anticipate and fetch resources required for subsequent pages, reducing latency and improving perceived performance. Prefetching, on the other hand, enables developers to specify resources that should be fetched in the background, ensuring that subsequent interactions or navigation are seamless and responsive.

\subsubsection{Serverless Deployment and APIs}

SvelteKit embraces the serverless paradigm, enabling effortless deployment of applications to serverless platforms like Netlify, Vercel, or AWS Lambda. The framework facilitates the creation of serverless functions, allowing developers to define custom server-side endpoints and build APIs without the need for separate server-side code. This streamlined deployment and serverless functionality simplify the scaling and maintenance of web applications, making SvelteKit a suitable choice for modern cloud-native architectures.

\subsection{Advantages of SvelteKit}

By combining the power of Svelte's compilation-based approach with the additional features provided by SvelteKit, developers can benefit from a range of advantages:

Improved performance through server-side rendering and optimized data fetching strategies.
Enhanced development productivity with built-in routing, data management, and serverless deployment.
Simplified code organization and maintenance due to the cohesive framework architecture.
Seamless integration with the Svelte ecosystem, enabling developers to leverage existing Svelte components, libraries, and tools.
It is worth noting that, similar to Svelte, SvelteKit is a relatively new framework, and its ecosystem is still evolving. While it provides a solid foundation for building web applications, developers should consider the maturity of third-party integrations and community support when selecting SvelteKit for their projects.

In conclusion, SvelteKit expands upon the capabilities of Svelte, offering a comprehensive framework for building web applications. With features such as server-side rendering, routing, data fetching, and serverless deployment, SvelteKit empowers developers to create high-performing and scalable applications with an improved development experience. By leveraging the strengths of Svelte's compilation-based approach, SvelteKit enhances productivity and provides a robust foundation for modern web development.

\section{Business Application}
\label{sec:business-application}

Our applications usually not public facing $\rightarrow$ SEO not relevant $\rightarrow$ SSR, FCP, TTI not as relevant
