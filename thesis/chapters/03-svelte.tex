\section{Svelte}
\label{sec:svelte}

Svelte was created in 2016 by Rich Harris as a successor to Ractive.js \cite{offerzen_origins_svelte_2022}. It is a framework for developing web user interfaces, similar to React, Angular, and Vue.js. Harris describes Svelte as a framework not to run code but to think about code \cite{offerzen_origins_svelte_2022}. Svelte's key difference compared to other web UI frameworks is, that it uses a Compiler. This makes it possible to shift many rendering steps from the run time into the build time. Therefore, Svelte can ship smaller and more efficient bundles. Furthermore, Svelte's Syntax can do things which would not be possible in vanilla JavaScript.

\subsection{Features}

\todo{Write something here}

\subsubsection{Svelte Files}
% - Files with .svelte ending
% - Syntax very similar to regular html with some extensions
% - standard javascript/Typescript $=>$ existing tools can be more easily integrated
% - javascript/html/css colocated in same file
% - {} to use js expressions in html, similar to react.
% - shorthand attribute syntax

Svelte is a custom language that is very similar to HTML, JavaScript, and CSS, which is colocated inside a \mintinline{bash}|.svelte| file. In fact, plain HTML syntax is also valid Svelte syntax:

\begin{myminted}{svelte}{app.svelte}
<h1>Hello World!</h1>
\end{myminted}

Logic can be added with a \texttt{<script>}-block and variables can be used outside the HTML with curly-braces:

\begin{myminted}{svelte}{}
<script>
  const name = 'world';
</script>

<div>Hello {name.toUpperCase()}!</div>
\end{myminted}

Similar to React, variables can also be used in element attributes, and Svelte even provides a shorthand when variable name and attribute name are the same:
\begin{myminted}{svelte}{}
<script>
  const src = './some/img.svg';
</script>

<img src={src}>
<img {src}>
\end{myminted}

\subsubsection{Reactivity}
% - asignments with usual js asignments. would not work in React.
% - unlike react, svelte runs script just once, for assignments, svelte inserts invalidate blocks to update a variable
% - compare svelte to equivalent react code.

Svelte provides a strong system for reactivity. Mutation of variables is done with regular assignment operations:

\begin{myminted}{svelte}{}
<script>
  let count = 0;

  function increment() {
    count += 1;
  }
</script>

<div>count: {count}!</div>
<button on:click={increment}>click me!</button>
\end{myminted}

This is possible, because Svelte's compiler replaces assignment operations at build time. The increment function in the prior example would be compiled to this statement:

\begin{myminted}[escapeinside=||]{js}{}
function increment() {
  |\$\$|invalidate('count', count += 1)
}
\end{myminted}

An equivalent React implementation using function components would have to use more verbose semantics, because without a specialized compiler, assignment operations do not have any special meaning:

\begin{myminted}{jsx}{}
function Component() {
  const [count, setCount] = useState(0);

  function increment() {
    setCount(c => c + 1);
  }

  return <>
    <div>count: {count}!</div>
    <button onClick={increment}>click me!</button>
  </>
}
\end{myminted}

React's code runs every time, a component is updated, this means derived values can just be declared, and they are evaluated every time. Svelte's code on the other hand, only runs once on component initialization. Therefore, Svelte introduces custom syntax for defining reactive statements. To This end, Svelte repurposes labeled statements:


\begin{myminted}[highlightlines={4},escapeinside=||]{svelte}{}
<script>
  let count = 2;

  |\$|: doubled = count * 2;

  function increment() {
    count += 1;
  }
</script>

<button on:click="{increment}">click me!</button>
<div>count: {count}!</div>
<div>doubled: {doubled}!</div>
\end{myminted}

% - $: to make reactive statement
% - repurpose of rarely used js feature
% - used for reactive assignments, conditions, and whole codeblocks
% - reactive block is rerun everytime a variable used inside the block changes

\mintinline{js}{$:} marks a statement as reactive. Every time a value, that is used in a reactive statement, changes, the statement is reevaluated. This can be used for assignments, as seen in the prior example, but it can also be used for conditions and code blocks:

\begin{myminted}[escapeinside=||]{svelte}{}
<script>
  let count = 0;

  |\$|: {
    console.log(`new value of count: ${count}`);
    console.log('This will also be executed when count changes');
  }

  |\$|: if(count > 9) {
    console.log('It is over 9!');
    count = 0;
  }
</script>
\end{myminted}
\s{$}

\subsubsection{Templates}

% - Templates for if, each

HTML does not have a way of expressing logic, thus Svelte introduces its own syntax. To conditionally render some markup, it is wrapped inside an if-block:

\begin{myminted}[highlightlines={11-14}]{svelte}{}
<script>
  let count = 0;

  function increment() {
    count += 1;
  }
</script>

<button on:click={increment}>click me!</button>
<div>count: {count}!</div>
{#if count > 9}
  <div>Vegeta what does the scouter say about his power level?</div>
  <div>It's over 9!!</div>
{:else}
  <div>The number ir pretty low</div>
{/if}
\end{myminted}

UI's also often work with lists of data. To this end, Svelte provides an each-block, which can be used to handle repeating data:

\begin{myminted}[highlightlines={5-7}]{svelte}{}
<script>
  let array = [1, 2, 3, 4];
</script>

{#each array as value}
  <div>{value}</div>
{/each}
\end{myminted}

\subsubsection{Components}

% - Since emergence of React, component driven development became norm.
% - in Svelte, one file = one component.
% - Name = Component Name.

% todo: citation needed
Since the emergence of React in 2013, component-driven user-interfaces have become a widespread approach to web development. In Svelte, a component is represented by a singular \mintinline{html}|.svelte|-file, where the file name determines the component name:

\begin{myminted}{html}{MyComponent.svelte}
<script>
  export let value;
</script>

<div>hello, {value}!</div>
\end{myminted}

To define props on a Component, Svelte repurposes the \mintinline{js}|export| keyword. The Component can than be imported and used like a regular element:

\begin{myminted}{svelte}{app.svelte}
<script>
  import MyComponent from './MyComponent.svelte';

  let value = 'world';
</script>

<MyComponent {value} />
\end{myminted}

\subsubsection{Events}

% - possible to listen to any event with on: 
% - custom events also

In a prior example we already showed usage of \mintinline{svelte}|on:click|. This directive is used to listen to click events. Svelte make sit possible to listen for arbitrary events on an element with the \mintinline{html}|on|-keyword:

\begin{myminted}[highlightlines={7}]{html}{}
<script>
  function handleMove(event) {
    // ...
  }
</script>

<div on:pointermove="{handleMove}" ></div>
\end{myminted}

Furthermore, Svelte provides an event dispatcher, so that components can throw their own custom events:

\begin{myminted}{html}{}
<script>
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function sayHello() {
    dispatch('message', {
      text: 'Hello!'
    });
  }
</script>
\end{myminted}

\subsubsection{Bindings}

\todo{two-way bindings}

% - usually data passed down. Parent can set props of child but not otherway around.
% - Svelte provides tool to work around that
% - simpler compared to react

\begin{myminted}{svelte}{}
<script>
  let name = 'Peter';
</script>

<input bind:value={name} />
\end{myminted}

\begin{myminted}{jsx}{}
function Component() {
  const [name, setName] = useState('Peter');

  return (
    <input
      value={name}
      onChange={e => setName(e.currentTarget.value)}
    />
  )
}
\end{myminted}

\subsubsection{TypeScript}

Svelte has out of the box support for TypeScript. TypeScript can be enabled for a svelte-file by annotating the  script block with a \mintinline{bash}|lang| attribute:

\begin{myminted}{svelte}{}
<script lang="ts">
  let value: string = "World"
</script>
\end{myminted}

This however, comes with certain restrictions. It is not possible to use TypeScript syntax outside the script block. One might for example want to type the parameters of an inline event handler:

\begin{myminted}{svelte}{}
<input on:change={(e: InputEvent) => {}}> /* this will not work */
\end{myminted}

\todo{Finish section / Fix syntax highlighting}


\section{SvelteKit}
\label{sec:sveltekit}

SvelteKit is a framework that builds around Svelte to provide a toolkit for rapidly developing web applications \cite{noauthor_sveltekit_nodate}. It can be used out of the box to develop full stack applications, server rendered frontend applications, static web pages, and traditional single page applications without any server rendering. It provides multiple basic, as well as advanced features, required for the development of modern web applications. Features include routing, support for different rendering patterns, build optimization, data preloading, and zero-configuration deployments. Furthermore, SvelteKit uses Vite\footnote{https://vitejs.dev/} to enable a good development experience, with fast startup times and quick hot module replacement.

% Meta Framework
% Stable release 2022
% provides functionality for modern applications
% Deployable as static files, web server, edge functions

\subsection{Features}
In the following we give an overview of multiple SvelteKit concepts and features, that will be relevant for the rest of this study.


\subsubsection{Routing}
\label{sec:sveltekit-routing}

SvelteKit provides out-of-the-box support for Routing. To this end, SvelteKit utilizes a file-system-based routing system. This means that the URL's that a user can access on the web application, directly maps to the directory structure in the project's file system. A SvelteKit project contains a \mintinline{bash}|routes|-directory. This directory marks the root of the URL, e.g.: \mintinline{bash}|http://example.com/|. Respectively, the directory structure \mintinline{bash}|routes/about| would map to \mintinline{bash}|http://example.com/about|. This system ca also be used to create parameterized routes. The directory structure \mintinline{bash}|routes/blog/[slug]| would create a route, where \mintinline{bash}|slug| serves as a wildcard (e.g.: \mintinline{bash}|/blog/hello-world|, \mintinline{bash}|/blog/123|).

The actual content of a page is defined in a \mintinline{bash}|+page.svelte| file:
\begin{myminted}{svelte}{routes/+page.svelte}
<h1>My Website</h1>
<p>Welcome to my website...</p>
\end{myminted}
\begin{myminted}{svelte}{routes/about/+page.svelte}
<h1>About</h1>
<p>about this site...</p>
<a href="/home">Home</a>
\end{myminted}

SvelteKit uses the HTML \mintinline{svelte}|<a>|-tag to navigate between pages, rather than a framework specific \mintinline{svelte}|<Link>|-component. This has the advantage of being progressively enhanceable. If JavaScript is not available on the client-side, the anchor-tag's navigation event can be handled by the browser, and the browser will do a regular full page reload to reach the navigation target. In the case of JS being available, SvelteKit's runtime router will intercept the navigation event and perform an in-app navigation to the target, without causing a full page reload.

Most websites have some elements that should be displayed across multiple pages, such as a navigation bar or a footer. To this end, SvelteKit's router has the concept of layouts. A layout is placed alongside the pages inside the \mintinline{bash}|routes|-directory, inside a \mintinline{bash}|+layout.svelte|-file. This layout will automatically be applied to all route and all sub-routes of the directory, where the layout-file is placed. The place where the actual page content should be rendered inside the layout is defined by a \mintinline{svelte}|<slot>|-element:

\begin{myminted}{svelte}{routes/+layout.svelte}
<nav>
  <a href="/home">home</a>
  <a href="/blog">blog</a>
  <a href="/about">about</a>
</nav>

<slot/>
\end{myminted}

In some cases an application may have multiple routes, that should live on the same route as others, but should have their own shared layout. One could for example imaging a website, where the user authentication pages should have a different layout than the authenticated area of the app. Therefore, SvelteKit provides a mechanism to group routes together without this route being reflected in the URL by wrapping the group name in parentheses:
\begin{myminted}[highlightlines={2,6}]{bash}{}
routes/
(app)/
  dashboard/
    details/
    +layout.svelte
  (auth)/
    signin/
    register/
    +layout.svelte
\end{myminted}

\subsubsection{Loading Data}
\label{sec:sveltekit-loading}

SvelteKit facilitates a standard way for fetching dynamic content that is to be rendered on a page. This is required to enable SSR and SSG. To this end, every page can have a dedicated load function, that is defined in a \mintinline{bash}|+page.js|-file. When a user requests a page, this load function is executed, and the returned data is passed to the \mintinline{bash}|+page.svelte|-file:

\begin{myminted}{js}{routes/+page.js}
    export async function load() {
            const todos = (await fetch('/api/todos')).json();

            return { todos };
        }
\end{myminted}
\begin{myminted}{svelte}{routes/+page.svelte}
<script>
  export let data;
</script>

{#each data.todos as todo}
  <div>{todo.name}</div>
{/each}
\end{myminted}

In SSR mode, when a user first requests a page, the load function is executed on the server. Afterwards the Svelte-file is rendered once, before being sent to the user as populated HTML. In the browser, SvelteKit then hydrates the page. During hydration, SvelteKit runs the load function a second time on the client to create a consistent data model.

After the app has finished hydrating, all following navigation events will be handled by SvelteKit's runtime router. When the user now navigates to a different page the load function now is invoked on the client-side directly, therefore saving an unnecessary roundtrip to the server. Because these load functions run on both server and the client, they are called universal load functions.

Some data fetching can only take place on the server-side, for example database access. Therefore, SvelteKit also provides a second form of load function, that is only executed on the server. These server load function are placed in \mintinline{bash}|+page.server.js|-files:

\begin{myminted}{js}{routes/+page.server.js}
import db from '$lib/server/db';

export async function load() {
  const todos = await db.getTodos();

  return { todos };
}
\end{myminted}
\s{$}

In the same way as universal load functions, server load functions are executed on the server when a user initially requests a page. But, because they can only run on the server, when a user navigates inside the app, instead of running the load function client-side, the client sends a request to the server for new data. The server then executes the load function and sends the resulting data back to the frontend as JSON.

This behavior also highlights another difference between universal and server load functions. Because server load functions need to be able to send JSON to the client, all data they return must be serializable. This restriction does not apply to universal load functions. Therefore, they can return arbitrary data such as class instances:

\begin{myminted}{js}{routes/+page.js}
    export async function load() {
            const todos =  [ new Todo(`finish master's thesis`) ]

            return { todos };
        }
\end{myminted}

\subsubsection{Form Actions}
\label{sec:sveltekit-server-actions}

The previous section discussed how SvelteKit applications send dynamic data to the client. But, many applications also need a way to send data to the server. To this end, SvelteKit provides Form actions. \mintinline{bash}|+page.server.js|-files can export actions, which make it possible to post data to the server using HTML's \mintinline{svelte}|<form>|-elements.

\begin{myminted}{svelte}{routes/+page.server.js}
    export const actions = {
    postTodo: async () => {
    // post Todo
    }
    }
\end{myminted}
\begin{myminted}{svelte}{routes/+page.svelte}
    <form method="POST" action="?/postTodo">
    <label>
    Todo name:
    <input name="todoName">
    </label>
    </form>
\end{myminted}

The name of the action, the form should post to, is specified as a query parameter. This makes it possible to have multiple actions per route. Because the implementation, uses only default HTML forms, it is again possible to progressively enhance this feature. In Fact, in the shown implementation, submitting, would cause a full page reload, because the browser is sending post request to the server. To progressively enhance this form, one can add the \mintinline{bash}|enhance| action:

\begin{myminted}{svelte}{routes/+page.svelte}
<script>
  import { enhance } from '$app/forms';
</script>

<form method="POST" action="?/postTodo" use:enhance>
\end{myminted}
\s{$}

This action intercepts form submit events and instead posts them to the server as an asynchronous request. This way the UI can provide better user experience, by foregoing the full page refresh.

\subsubsection{Rendering}

SvelteKit provides the functionality to define the rendering strategy for each route independently.
By exporting the constants \mintinline{bash}|ssr|, \mintinline{bash}|csr| and \mintinline{bash}|prerender| the rendering behavior of page can be precisely changed:
\begin{myminted}{js}{routes/page.js}
export const prerender = false;
export const ssr = true;
export const csr = true;
\end{myminted}

\begin{itemize}
    \item Setting \mintinline{bash}|prerender| to true, the page will render this page during the build process and serve this route as static files. This also means this route cannot have form actions, because SvelteKit will not provide handlers for a pre-rendered route.
    \item \mintinline{bash}|ssr| determines if the page should be rendered on the server site when the user first requests the page. This does not mean the page cannot specify a server load function. Instead, the client will simply request the data from the server load function as soon as the runtime is initialized on the client side. This option can sometimes be useful, when a page requires certain features that require access to browser exclusive API's to render its content. But, most of the time it is possible to defer access to these browser-specific API's by running the code after the function has been mounted.
    \item With \mintinline{bash}|csr| it is possible to completely disable client-side JavaScript. But this has certain side effects. For example, given an application has a layout that contains a navigation bar which needs JavaScript to work. If the user first loads the website on a page that has CSR disabled, the navigation bar will not work. On the other hand, if the user loads the website on a page that has CSR enabled and then navigates to a page with CSR set to false, the navigation bar will work.
\end{itemize}